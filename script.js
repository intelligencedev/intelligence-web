const starTypes = [{ type: "O-type", colorRange: { min: [.2, .2, .9], max: [.4, .4, 1] } }, { type: "B-type", colorRange: { min: [.6, .7, 1], max: [.8, .9, 1] } }, { type: "A-type", colorRange: { min: [.8, .8, .95], max: [.9, .9, 1] } }, { type: "F-type", colorRange: { min: [.95, .95, .8], max: [1, 1, .9] } }, { type: "G-type", colorRange: { min: [1, .95, .7], max: [1, 1, .8] } }, { type: "K-type", colorRange: { min: [1, .6, .4], max: [1, .8, .6] } }, { type: "M-type", colorRange: { min: [1, .3, .3], max: [1, .5, .5] } }, { type: "Red Giant", colorRange: { min: [1, .4, .2], max: [1, .6, .4] } }, { type: "White Dwarf", colorRange: { min: [.7, .7, .9], max: [.9, .9, 1] } }, { type: "Brown Dwarf", colorRange: { min: [.3, .15, .1], max: [.5, .3, .2] } }], scene = new THREE.Scene, camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, .1, 1e3), renderer = new THREE.WebGLRenderer({ antialias: !0 }); renderer.setSize(window.innerWidth, window.innerHeight), document.body.appendChild(renderer.domElement), camera.position.set(.28, -3.04, .78), camera.rotation.set(1.32, .09, 0); const controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = !0, controls.dampingFactor = .25, controls.enableZoom = !0; const galaxyGroup = new THREE.Group; scene.add(galaxyGroup); const controlParams = { rotationSpeed: 5e-4 }, galaxyParams = { numStars: 2e5, starSize: .01, galacticRadius: 15, spiralArms: 2, coreRadius: .5, numNebulaParticles: 5e4 }; function getRandomColorInRange(e) { const a = THREE.MathUtils.lerp(e.min[0], e.max[0], Math.random()), t = THREE.MathUtils.lerp(e.min[1], e.max[1], Math.random()), n = THREE.MathUtils.lerp(e.min[2], e.max[2], Math.random()); return new THREE.Color(a, t, n) } function createCircularGradientTexture() { const e = 256, a = document.createElement("canvas"); a.width = e, a.height = e; const t = a.getContext("2d"), n = t.createRadialGradient(128, 128, 0, 128, 128, 128); n.addColorStop(0, "rgba(255, 255, 255, 1)"), n.addColorStop(1, "rgba(255, 255, 255, 0)"), t.clearRect(0, 0, e, e), t.fillStyle = n, t.fillRect(0, 0, e, e); const o = new THREE.CanvasTexture(a); return o.needsUpdate = !0, o.minFilter = THREE.LinearFilter, o.wrapS = THREE.ClampToEdgeWrapping, o.wrapT = THREE.ClampToEdgeWrapping, o.format = THREE.RGBAFormat, o } function fractalNoise(e, a, t, n) { let o = 0, r = 1, i = 1, l = 0; for (let s = 0; s < a; s++)o += generatePerlinNoise(e.x * r, e.y * r) * i, l += i, i *= t, r *= n; return o / l } function generatePerlinNoise(e, a) { function t(e) { return e * e * e * (e * (6 * e - 15) + 10) } function n(e, a, t) { return e + t * (a - e) } function o(e, a, t) { const n = 3 & e, o = n < 2 ? a : t, r = n < 2 ? t : a; return (1 & n ? -o : o) + (2 & n ? -r : r) } const r = [151, 160, 137, 91, 90, 15, 151]; return function (e, a) { const i = 255 & Math.floor(e), l = 255 & Math.floor(a); e -= Math.floor(e), a -= Math.floor(a); const s = t(e), d = t(a), m = r[r[i] + l + 1], u = r[r[i + 1] + l], c = r[r[i + 1] + l + 1]; return (n(n(o(r[r[i] + l], e, a), o(u, e - 1, a), s), n(o(m, e, a - 1), o(c, e - 1, a - 1), s), d) + 1) / 2 }(.1 * e, .1 * a) } function generateGalaxyStars() { const e = new THREE.BufferGeometry, a = [], t = []; for (let e = 0; e < galaxyParams.numStars; e++) { const n = e % galaxyParams.spiralArms * (2 * Math.PI / galaxyParams.spiralArms), o = Math.max(.1, Math.pow(Math.random(), 2) * galaxyParams.galacticRadius), r = n + 2.9 * o + 1 * (Math.random() - .5), i = o * Math.cos(r), l = o * Math.sin(r), s = .5 * (Math.random() - .5); if (o < galaxyParams.coreRadius || o > galaxyParams.galacticRadius) continue; a.push(i, l, s); const d = getRandomColorInRange(starTypes[Math.floor(Math.random() * starTypes.length)].colorRange); t.push(d.r, d.g, d.b) } e.setAttribute("position", new THREE.Float32BufferAttribute(a, 3)), e.setAttribute("color", new THREE.Float32BufferAttribute(t, 3)); const n = new THREE.PointsMaterial({ size: galaxyParams.starSize, map: createCircularGradientTexture(), vertexColors: !0, transparent: !0, blending: THREE.AdditiveBlending, depthWrite: !1 }); return new THREE.Points(e, n) } function generateNebula() { const e = new THREE.Group; for (let a = 0; a < 3; a++) { const t = new THREE.BufferGeometry, n = [], o = [], r = [], i = [], l = 1 + .3 * a; for (let e = 0; e < galaxyParams.numNebulaParticles; e++) { const e = 2 * Math.random() * Math.PI, a = Math.pow(Math.random(), 1.5) * galaxyParams.galacticRadius * l; if (a < galaxyParams.coreRadius || a > galaxyParams.galacticRadius) continue; const t = a * Math.cos(e), s = a * Math.sin(e), d = .5 * (Math.random() - .5); n.push(t, s, d), r.push(e), i.push(a); const m = .55 + .3 * fractalNoise({ x: t, y: s }, 5, .5, 2), u = (new THREE.Color).setHSL(m, .7, .5); o.push(u.r, u.g, u.b) } t.setAttribute("position", new THREE.Float32BufferAttribute(n, 3)), t.setAttribute("color", new THREE.Float32BufferAttribute(o, 3)), t.setAttribute("angle", new THREE.Float32BufferAttribute(r, 1)), t.setAttribute("radius", new THREE.Float32BufferAttribute(i, 1)); const s = new THREE.ShaderMaterial({ uniforms: rotationShader.uniforms, vertexShader: rotationShader.vertexShader, fragmentShader: rotationShader.fragmentShader, vertexColors: !0, transparent: !0, blending: THREE.AdditiveBlending, depthWrite: !1 }), d = new THREE.Points(t, s); e.add(d) } return e } const rotationShader = { uniforms: { time: { value: 0 }, rotationSpeed: { value: .1 }, size: { value: galaxyParams.starSize } }, vertexShader: "\n        uniform float time;\n        uniform float rotationSpeed;\n        uniform float size;\n\n        attribute float angle;\n        attribute float radius;\n        attribute float speed;\n\n        varying vec3 vColor;\n\n        void main() {\n            float rotationAngle = angle + time * rotationSpeed * speed;\n            vec3 newPosition = vec3(\n                radius * cos(rotationAngle),\n                radius * sin(rotationAngle),\n                position.z\n            );\n\n            vColor = color; // Use the built-in color attribute\n\n            vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);\n            gl_Position = projectionMatrix * mvPosition;\n            \n            // Updated point size logic\n            gl_PointSize = size * (100.0 / -mvPosition.z); // Scale with distance\n        }\n    ", fragmentShader: "\n        varying vec3 vColor;\n\n        void main() {\n            gl_FragColor = vec4(vColor, 1.0);\n        }\n    " }; galaxyGroup.add(generateGalaxyStars()), galaxyGroup.add(generateNebula()); const blackHole = new THREE.Mesh(new THREE.SphereGeometry(galaxyParams.coreRadius, 32, 32), new THREE.MeshBasicMaterial({ color: 0 })); scene.add(blackHole); const pointLight = new THREE.PointLight(16777215, 1, 100); pointLight.position.set(0, 0, 0), scene.add(pointLight); const composer = new THREE.EffectComposer(renderer), renderPass = new THREE.RenderPass(scene, camera); composer.addPass(renderPass); const lensingShader = { uniforms: { tDiffuse: { value: null }, uTime: { value: 0 }, blackHolePosition: { value: new THREE.Vector2(.5, .5) }, blackHoleRadius: { value: galaxyParams.coreRadius } }, vertexShader: "\n        varying vec2 vUv;\n\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n    ", fragmentShader: "\n        uniform sampler2D tDiffuse;\n        uniform vec2 blackHolePosition;\n        uniform float blackHoleRadius;\n        varying vec2 vUv;\n\n        void main() {\n            vec2 coord = vUv;\n            float distance = length(blackHolePosition - vUv);\n            if (distance < blackHoleRadius) {\n                float distortion = 1.0 - smoothstep(0.0, blackHoleRadius, distance);\n                coord -= normalize(vUv - blackHolePosition) * distortion * 0.2;\n            }\n            gl_FragColor = texture2D(tDiffuse, coord);\n        }\n    " }; function getCameraDistanceToBlackHole() { return camera.position.length() } function updateLensingEffect() { const e = getCameraDistanceToBlackHole(); lensingPass.uniforms.blackHoleRadius.value = galaxyParams.coreRadius / e } const lensingPass = new THREE.ShaderPass(lensingShader); lensingPass.uniforms.blackHolePosition.value = new THREE.Vector2(.5, .5), composer.addPass(lensingPass); const GodRayShader = { uniforms: { tDiffuse: { value: null }, lightPosition: { value: new THREE.Vector2(.5, .5) }, exposure: { value: .85 }, decay: { value: .95 }, density: { value: .96 }, weight: { value: .5 }, samples: { value: 60 } }, vertexShader: "\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n    ", fragmentShader: "\n        uniform sampler2D tDiffuse;\n        uniform vec2 lightPosition;\n        uniform float exposure;\n        uniform float decay;\n        uniform float density;\n        uniform float weight;\n        uniform int samples;\n\n        varying vec2 vUv;\n\n        void main() {\n            vec2 texCoord = vUv;\n            vec2 deltaTextCoord = texCoord - lightPosition;\n            deltaTextCoord *= 1.0 / float(samples) * density;\n            vec4 originalColor = texture2D(tDiffuse, texCoord);\n            float illuminationDecay = 1.0;\n\n            vec4 shadowEffect = vec4(0.0);\n\n            for (int i = 0; i < samples; i++) {\n                texCoord -= deltaTextCoord;\n                vec4 sampleColor = texture2D(tDiffuse, texCoord);\n                sampleColor *= illuminationDecay * weight;\n\n                shadowEffect += sampleColor;\n                illuminationDecay *= decay;\n            }\n\n            vec3 resultColor = mix(originalColor.rgb, shadowEffect.rgb, 0.5);\n            resultColor += originalColor.rgb * 0.3;\n\n            gl_FragColor = vec4(resultColor, originalColor.a) * exposure;\n        }\n    " }, godRayPass = new THREE.ShaderPass(GodRayShader); function animate() { requestAnimationFrame(animate), galaxyGroup.rotation.z += controlParams.rotationSpeed, updateLensingEffect(), galaxyGroup.children.forEach((e => { e.material && e.material.uniforms && (e.material.uniforms.time.value += .01) })), updateInfoPanel(), composer.render() } function updateCameraRotation(e) { console.log("Camera rotation updated:", e.target.id), camera.rotation.x = parseFloat(document.getElementById("camera-rotation-x").value), camera.rotation.y = parseFloat(document.getElementById("camera-rotation-y").value), camera.rotation.z = parseFloat(document.getElementById("camera-rotation-z").value), updateInfoPanel() } function updateInfoPanel() { document.getElementById("info-content").innerHTML = `\n        <p><strong>Camera Position:</strong> x: ${camera.position.x.toFixed(2)}, y: ${camera.position.y.toFixed(2)}, z: ${camera.position.z.toFixed(2)}</p>\n        <p><strong>Camera Rotation:</strong> x: ${camera.rotation.x.toFixed(2)}, y: ${camera.rotation.y.toFixed(2)}, z: ${camera.rotation.z.toFixed(2)}</p>\n    ` } function toggleParametersMenu() { const e = document.getElementById("parameters-menu"); e.style.display = "none" === e.style.display || "" === e.style.display ? "block" : "none" } function toggleInfoPanel() { const e = document.getElementById("info-panel"); "none" === e.style.display || "" === e.style.display ? (e.style.display = "block", document.getElementById("info-button").innerText = "Hide Info") : (e.style.display = "none", document.getElementById("info-button").innerText = "Show Info") } function updateBlackHoleSize() { blackHole.geometry.dispose(), blackHole.geometry = new THREE.SphereGeometry(galaxyParams.coreRadius, 32, 32) } function updateGalaxyParameters() { galaxyParams.numStars = parseInt(document.getElementById("num-stars").value), galaxyParams.starSize = parseFloat(document.getElementById("star-size").value), galaxyParams.galacticRadius = parseInt(document.getElementById("galactic-radius").value), galaxyParams.spiralArms = parseInt(document.getElementById("spiral-arms").value), galaxyParams.coreRadius = parseFloat(document.getElementById("core-radius").value), galaxyParams.numNebulaParticles = parseInt(document.getElementById("num-nebula-particles").value), galaxyGroup.children.forEach((e => { e.material && e.material.uniforms && e.material.uniforms.size && (e.material.uniforms.size.value = galaxyParams.starSize) })), regenerateGalaxy() } function regenerateGalaxy() { galaxyGroup.clear(), galaxyGroup.add(generateGalaxyStars()), galaxyGroup.add(generateNebula()) } godRayPass.uniforms.lightPosition.value = new THREE.Vector2(.5, .5), composer.addPass(godRayPass), animate(), document.addEventListener("DOMContentLoaded", (function () { document.getElementById("camera-rotation-x").addEventListener("input", updateCameraRotation), document.getElementById("camera-rotation-y").addEventListener("input", updateCameraRotation), document.getElementById("camera-rotation-z").addEventListener("input", updateCameraRotation), document.getElementById("parameters-button").addEventListener("click", toggleParametersMenu), document.getElementById("info-button").addEventListener("click", toggleInfoPanel) })), window.addEventListener("resize", (() => { camera.aspect = window.innerWidth / window.innerHeight, camera.updateProjectionMatrix(), renderer.setSize(window.innerWidth, window.innerHeight), composer.setSize(window.innerWidth, window.innerHeight) })), document.getElementById("camera-rotation-x").addEventListener("input", updateCameraRotation), document.getElementById("camera-rotation-y").addEventListener("input", updateCameraRotation), document.getElementById("camera-rotation-z").addEventListener("input", updateCameraRotation), document.getElementById("star-size").addEventListener("input", (() => { galaxyParams.starSize = parseFloat(document.getElementById("star-size").value), galaxyGroup.children.forEach((e => { e.isPoints && (e.material.size = galaxyParams.starSize, e.material.needsUpdate = !0) })), console.log("Star size updated to:", galaxyParams.starSize) })), document.getElementById("core-radius").addEventListener("input", (() => { galaxyParams.coreRadius = parseFloat(document.getElementById("core-radius").value), updateBlackHoleSize(), updateLensingEffect(), regenerateGalaxy() })), document.addEventListener("DOMContentLoaded", (function () { document.getElementById("camera-rotation-x").addEventListener("input", updateCameraRotation), document.getElementById("camera-rotation-y").addEventListener("input", updateCameraRotation), document.getElementById("camera-rotation-z").addEventListener("input", updateCameraRotation), document.getElementById("num-stars").addEventListener("input", updateGalaxyParameters), document.getElementById("star-size").addEventListener("input", updateGalaxyParameters), document.getElementById("galactic-radius").addEventListener("input", updateGalaxyParameters), document.getElementById("spiral-arms").addEventListener("input", updateGalaxyParameters), document.getElementById("core-radius").addEventListener("input", updateGalaxyParameters), document.getElementById("num-nebula-particles").addEventListener("input", updateGalaxyParameters), document.getElementById("parameters-button").addEventListener("click", toggleParametersMenu), document.getElementById("info-button").addEventListener("click", toggleInfoPanel) }));
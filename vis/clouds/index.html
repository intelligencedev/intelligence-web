<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Dreamy Volumetric Clouds</title>
  <style>
    body,
    html {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #87ceeb;
    }

    canvas {
      display: block;
    }

    #gui {
      position: absolute;
      top: 0;
      right: 0;
    }
  </style>
</head>

<body>
  <div id="gui"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import { GUI } from 'https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js';

    /* --------------------------------------------------------------
       Renderer, scene & camera
       -------------------------------------------------------------- */
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(1); // Internal resolution = 1x
    renderer.setSize(window.innerWidth, window.innerHeight); // Canvas fills window
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);
    scene.add(camera);

    /* --------------------------------------------------------------
       Uniforms (same as in your original code)
       -------------------------------------------------------------- */
    const uniforms = {
      u_time: { value: 0.0 },
      u_resolution: { value: new THREE.Vector2(window.innerWidth/2, window.innerHeight/2) },
      u_stepSize: { value: 0.062 },           // Step Size
      u_maxSteps: { value: 62, type: 'i' },   // Max Steps
      u_density: { value: 2.0 },              // Density
      u_scatter: { value: 0.3 },              // Scatter
      u_asymmetry: { value: 0.01 },           // Asymmetry
      u_lightDir: { value: new THREE.Vector3(0.19, 1.0, 0.82).normalize() }, // Light X/Y/Z
      u_cloudCenter: { value: new THREE.Vector3(0, 0, 0) },
      u_cloudRadius: { value: 3.0 },
      u_cloudColor: { value: new THREE.Color(1, 1, 1) }, // Cloud R/G/B
      u_fogColor: { value: new THREE.Color(0.24, 0.62, 0.83) }, // Fog R/G/B
      u_fogDensity: { value: 0.1 },            // Fog Density
      u_cloudSpeed: { value: 0.1 },            // Cloud Speed
      u_lightIntensity: { value: 15.0 },       // Light Intensity
      u_noiseScale: { value: 0.7 },            // Noise Scale
      u_noiseDetail: { value: 8 },             // Noise Detail
      u_noiseStrength: { value: 2.0 },         // Noise Strength
    };

    /* --------------------------------------------------------------
       Shaders
       -------------------------------------------------------------- */
    const vertexShader = `
precision mediump float;
attribute vec3 position;
void main(){ gl_Position = vec4(position,1.0); }
`;

    // Fragment shader
    const fragmentShader = `
precision highp float;

uniform float  u_time;
uniform vec2   u_resolution;
uniform float  u_stepSize;
uniform int    u_maxSteps;
uniform float  u_density;
uniform float  u_scatter;
uniform float  u_asymmetry;
uniform vec3   u_lightDir;
uniform vec3   u_cloudCenter;
uniform float  u_cloudRadius;
uniform vec3   u_cloudColor;
uniform vec3   u_fogColor;
uniform float  u_fogDensity;
uniform float  u_cloudSpeed;
uniform float  u_lightIntensity; // NEW
uniform float  u_noiseScale;
uniform float  u_noiseStrength;
uniform int    u_noiseDetail;

// Blue noise texture sampler (expects a 2D blue noise texture bound to channel 0)
uniform sampler2D u_blueNoise;

/* --------------------------------------------------------------
   3‑D simplex noise (GLSL‑ported from Stefan Gustavson)
   -------------------------------------------------------------- */
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

float snoise(vec3 v){
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

    // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 = v - i + dot(i, C.xxx) ;

    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    //  x0 = x0 - 0.0 + 0.0 * C
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy; // 1.0*C.x = 1/3
    vec3 x3 = x0 - D.yyy;      // 1.0 - 1/6 = 5/6

    // Permutations
    i = mod(i, 289.0 );
    vec4 p = permute( permute( permute(
               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

    // Gradients: 7x7 points over a square, mapped onto an octahedron.
    float n_ = 1.0/7.0; // N=7
    vec3  ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    //vec4 s0 = floor(b0)*2.0 + 1.0;
    //vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

    // Normalise gradients
    vec4 norm = taylorInvSqrt( vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)) );
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    // Mix contributions from the four corners
    vec4 m = max( 0.6 - vec4(dot(x0,x0), dot(x1,x1),
                          dot(x2,x2), dot(x3,x3) ), 0.0 );
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                 dot(p2,x2), dot(p3,x3) ) );
}

/* --------------------------------------------------------------
   Fractal Brownian Motion – reduced to 4 octaves
   -------------------------------------------------------------- */
float fbm(vec3 p){
    float sum   = 0.0;
    float amp   = 0.5 * u_noiseStrength;
    float freq  = u_noiseScale;
    for(int i=0; i<8; i++){
        if(i >= u_noiseDetail) break;
        sum  += amp * snoise(p * freq);
        freq *= 2.0;
        amp  *= 0.5;
    }
    return sum;
}

/* --------------------------------------------------------------
   Henyey‑Greenstein phase function (single‑scattering)
   -------------------------------------------------------------- */
float hgPhase(float cosTheta, float g){
    float gg = g*g;
    return (1.0-gg) / (4.0*3.14159265*pow(1.0 + gg - 2.0*g*cosTheta, 1.5));
}

/* --------------------------------------------------------------
   Main
   -------------------------------------------------------------- */
void main(){
    // Normalised screen coordinates, centred at (0,0)
    vec2 uv = (gl_FragCoord.xy / u_resolution) * 2.0 - 1.0;
    // Remove aspect ratio correction to prevent stretching
    // uv.x *= u_resolution.x / u_resolution.y; // <-- commented out

    // --------------------------------------------------------------
    // Camera & ray setup (simple pin‑hole)
    // --------------------------------------------------------------
    vec3 camPos   = vec3(0.0, 0.0, -3.0);          // eye
    vec3 rayDir   = normalize( vec3(uv, 1.0) );   // forward = +z

    // --------------------------------------------------------------
    // Intersect ray with the spherical cloud volume
    // --------------------------------------------------------------
    // Solve (p + t*dir - centre)^2 = radius^2
    vec3 oc = camPos - u_cloudCenter;
    float b = dot(oc, rayDir);
    float c = dot(oc, oc) - u_cloudRadius*u_cloudRadius;
    float disc = b*b - c;
    if (disc < 0.0) {
        // Output sky color if ray misses the sphere
        vec2 skyUv = (gl_FragCoord.xy / u_resolution) * 2.0 - 1.0;
        // Also remove aspect correction here
        vec3 sky = mix(vec3(0.6,0.8,1.0), u_fogColor, skyUv.y*0.5+0.5);
        gl_FragColor = vec4(sky, 1.0);
        return;
    }

    float sqrtDisc = sqrt(disc);
    float t0 = -b - sqrtDisc;   // entry
    float t1 = -b + sqrtDisc;   // exit
    t0 = max(t0, 0.0);           // we start inside the near‑plane

    // --------------------------------------------------------------
    // Ray‑march loop
    // --------------------------------------------------------------
    float step = u_stepSize;                // base step size
    vec3  pos = camPos + rayDir * t0;        // current sample position
    float traveled = t0;                    // distance already travelled
    float maxDist  = t1;                    // far end of the sphere

    vec3  colAccum = vec3(0.0);
    float trans    = 1.0;                   // accumulated transmittance

    for(int i=0; i<256; i++){
        if(i >= u_maxSteps) break;
        if(traveled > maxDist) break;
        if(trans < 0.01) break;

        // ----------------------------------------------------------
        // Sample the density field
        // ----------------------------------------------------------
        // Add a slow "wind" by moving the noise field over time
        vec3 p = pos * u_noiseScale + u_time * u_cloudSpeed * vec3(1.0, 0.6, 0.8);
        float d = fbm(p) * u_density;
        d = smoothstep(0.3, 0.7, d);        // make a nice soft edge

        // ----------------------------------------------------------
        // Light scattering (single‑scattering only)
        // ----------------------------------------------------------
        float cosTheta = dot(rayDir, u_lightDir);
        float phase    = hgPhase(cosTheta, u_asymmetry);
        vec3  light    = vec3(1.0,0.95,0.9) * phase * u_lightIntensity; // <-- use intensity

        // Scattered radiance for this step
        vec3  scattering = u_cloudColor * light * u_scatter;

        // ----------------------------------------------------------
        // Accumulate colour using the classic volume rendering equation
        // ----------------------------------------------------------
        // Sample blue noise for dithering
        vec2 noiseUV = gl_FragCoord.xy / u_resolution;
        float blueNoise = texture2D(u_blueNoise, noiseUV).r;

        // Add blue noise to density for dithering
        float ditheredDensity = d + (blueNoise - 0.5) * 0.08;

        float absorb   = exp(-ditheredDensity * step);
        float contrib  = (1.0 - absorb) * trans;
        colAccum += scattering * contrib;
        trans   *= absorb;

        // ----------------------------------------------------------
        // Advance the ray
        // ----------------------------------------------------------
        // Optional: shrink the step size near the centre to give a
        // finer detail where the eye spends most time.
        float distToCenter = length(pos - u_cloudCenter);
        float adapt = mix(1.0, 0.3, smoothstep(0.0, u_cloudRadius*0.5, distToCenter));
        pos      += rayDir * step * adapt;
        traveled += step * adapt;
    }

    // --------------------------------------------------------------
    // Atmospheric fog (exponential) + sky gradient
    // --------------------------------------------------------------
    float fog = exp(-u_fogDensity * traveled);
    vec3 sky = mix(vec3(0.6,0.8,1.0), u_fogColor, uv.y*0.5+0.5); // simple vertical gradient
    vec3 final = mix(sky, colAccum, fog);

    // --------------------------------------------------------------
    // Output
    // --------------------------------------------------------------
    gl_FragColor = vec4(final, 1.0);
}`;

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute([
      -1, -1, 0, 1, -1, 0, -1, 1, 0,
      -1, 1, 0, 1, -1, 0, 1, 1, 0
    ], 3));

    // Add blue noise texture loading in JS
    const blueNoiseTexture = new THREE.TextureLoader().load(
      'https://raw.githubusercontent.com/Erkaman/glsl-blue-noise/master/data/blue-noise.png'
    );
    blueNoiseTexture.wrapS = THREE.RepeatWrapping;
    blueNoiseTexture.wrapT = THREE.RepeatWrapping;
    blueNoiseTexture.minFilter = THREE.LinearFilter;
    blueNoiseTexture.magFilter = THREE.LinearFilter;

    // Add to uniforms
    uniforms.u_blueNoise = { value: blueNoiseTexture };

    const material = new THREE.RawShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms,
      transparent: true
    });
    scene.add(new THREE.Mesh(geometry, material));

    /* --------------------------------------------------------------
       GUI (unchanged)
       -------------------------------------------------------------- */
    const gui = new GUI({ autoPlace: false });
    document.getElementById('gui').appendChild(gui.domElement);
    gui.add(uniforms.u_stepSize, 'value', 0.01, 0.08).name('Step Size');
    gui.add(uniforms.u_maxSteps, 'value', 32, 128, 1).name('Max Steps');
    gui.add(uniforms.u_density,  'value', 0.2, 2.0).name('Density');
    gui.add(uniforms.u_scatter,  'value', 0.0, 1.0).name('Scatter');
    gui.add(uniforms.u_asymmetry,'value', -0.9, 0.9).name('Asymmetry');
    gui.add(uniforms.u_lightDir.value, 'x', -1, 1).name('Light X');
    gui.add(uniforms.u_lightDir.value, 'y', -1, 1).name('Light Y');
    gui.add(uniforms.u_lightDir.value, 'z', -1, 1).name('Light Z');
    gui.add(uniforms.u_cloudColor.value, 'r', 0, 1).name('Cloud R');
    gui.add(uniforms.u_cloudColor.value, 'g', 0, 1).name('Cloud G');
    gui.add(uniforms.u_cloudColor.value, 'b', 0, 1).name('Cloud B');
    gui.add(uniforms.u_fogColor.value, 'r', 0, 1).name('Fog R');
    gui.add(uniforms.u_fogColor.value, 'g', 0, 1).name('Fog G');
    gui.add(uniforms.u_fogColor.value, 'b', 0, 1).name('Fog B');
    gui.add(uniforms.u_fogDensity, 'value', 0.0, 0.1).name('Fog Density');
    gui.add(uniforms.u_cloudSpeed, 'value', 0.0, 2.0).name('Cloud Speed');
    gui.add(uniforms.u_lightIntensity, 'value', 0.1, 15.0).name('Light Intensity');
    gui.add(uniforms.u_noiseScale, 'value', 0.5, 4.0).name('Noise Scale');
    gui.add(uniforms.u_noiseDetail, 'value', 1, 8, 1).name('Noise Detail');
    gui.add(uniforms.u_noiseStrength, 'value', 0.5, 2.0).name('Noise Strength');

    /* --------------------------------------------------------------
       Animation loop & resize handling
       -------------------------------------------------------------- */
    function animate() {
      uniforms.u_time.value += 0.016; // Fixed increment per frame for consistent animation
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // On resize, keep canvas full screen but shader at 1/4 resolution
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      uniforms.u_resolution.value.set(window.innerWidth/2, window.innerHeight/2);
    });
  </script>
</body>

</html>